 # LRU cache (generics) + interface + “friendly goroutines”

Цель задания — реализовать потокобезопасный (concurrent-safe) LRU-кэш на Go с использованием дженериков и интерфейса. Решение должно проходить приложенные тесты.

Что такое LRU
LRU (Least Recently Used) — кэш фиксированной ёмкости. Когда кэш переполнен и добавляется новый ключ, удаляется *наименее недавно использованный* элемент.

“Использованный” = к нему обращались через Get() или его обновляли через Set() (то есть он становится MRU — most recently used).

Требуемое публичное API
Код тестов ожидает, что у вас в package main будут:

1) Интерфейс:

type LRU[K comparable, V any] interface {
 Get(key K) (V, bool)
 Set(key K, value V)
}


2) Реализация:

type LRUCache[K comparable, V any] struct { /* ... */ }


3) Конструктор:

func NewLRUCache[K comparable, V any](capacity int) *LRUCache[K, V]


Методы Get/Set должны быть определены на *LRUCache[K,V], чтобы проходила проверка:

var _ LRU[string, string] = (*LRUCache[string, string])(nil)


Семантика (поведение), которую проверяют тесты
1) Get(key):
- Если ключ *есть*: вернуть (value, true) и сделать этот ключ *MRU* (обновить “недавность”).
- Если ключа *нет*: вернуть (zeroValue, false), где zeroValue — нулевое значение типа V.

2) Set(key, value):
- Если ключа ещё нет:
  - добавить элемент;
  - если после добавления размер превышает capacity, удалить *LRU* элемент.
- Если ключ уже есть:
  - обновить значение;
  - сделать ключ *MRU*;
  - важно: *обновление существующего ключа не должно вызывать eviction само по себе* (eviction происходит только если вы добавляете новый ключ и превышаете capacity).

3) capacity:
- capacity == 0: кэш ничего не хранит. После любых Set все Get должны возвращать ok=false.
- capacity == 1: хранится максимум один элемент, корректный eviction.

4) Нулевые значения:
- Кэш должен уметь хранить V равное zero value (например "" или 0) и отличать это от “ключ отсутствует” через ok.

Требования по конкурентности (“friendly goroutines”)
Тесты запускают много горутин, которые одновременно вызывают Get/Set. Требования:
- Не должно быть паник.
- Не должно быть дедлоков (есть таймаут 5 секунд).
- Должна быть корректная синхронизация: чтение/запись внутренних структур (map/list/узлы) — строго защищены.
- Должна сохраняться целостность значений: тест “torn read” проверяет, что при чтении структуры-значения нет “разорванного” состояния (обычно это достигается тем, что Get/Set атомарны относительно друг друга с помощью mutex).

Практический вывод: делайте Get и Set потокобезопасными (обычно через sync.Mutex). sync.RWMutex использовать можно, но помните: Get() меняет порядок (recency), значит это *не чистое чтение*.

Ожидаемая сложность
Желательно (и типично для LRU):
- Get — O(1)
- Set — O(1)

![task 07](../../badges/tasks/task_07.svg)

// TODO!!!