Cache

![task 05](../../badges/tasks/task_05.svg)

В этом задании нужно реализовать простой in-memory cache на Go с использованием generics.

**Что нужно реализовать**
API должен совпадать с тем, как он используется в тестах:

- `NewCache[K, V](capacity int) *Cache[K, V]`
- `(c *Cache[K, V]) Set(key K, value V)`
- `(c *Cache[K, V]) Get(key K) (V, bool)`

Ожидаемые ограничения типов:
- `K` должен быть `comparable` (чтобы использовать `map`)
- `V` — любой тип (`any`)

Пример каркаса:


type Cache[K comparable, V any] struct {
    // ваша реализация
}

func NewCacheK comparable, V any *Cache[K, V] { /* ... */ }

func (c *Cache[K, V]) Set(key K, value V) { /* ... */ }

func (c *Cache[K, V]) Get(key K) (V, bool) { /* ... */ }


**Правила поведения**
1) **Базовые операции**
- `Set` сохраняет значение по ключу.
- `Get` возвращает `(value, true)`, если ключ есть, иначе — `(zeroValue, false)`.

2) **Обновление**
- Если вызвать `Set` с ключом, который уже есть в кэше — значение должно обновиться.

3) **Параметр `capacity`**
В рамках этих тестов `capacity` **не является лимитом на количество элементов** (вытеснения/eviction делать не нужно).
Единственное обязательное поведение про `capacity`, которое проверяется тестами:

- если `capacity == 0`, кэш считается “выключенным”:
  - `Set` ничего не сохраняет
  - `Get` всегда возвращает `ok = false`

Если `capacity > 0`, вы можете использовать его как “подсказку” для начального размера структуры (например, `make(map[K]V, capacity)`), но не обязаны ограничивать размер.

**Требования**
- Разрешено использовать стандартную библиотеку.
- Потокобезопасность не требуется.
- Прохождение тестов

