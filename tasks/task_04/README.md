# Потоковая агрегация

![task 04](../../badges/tasks/task_04.svg)

В этом задании нужно реализовать простую «потоковую» агрегацию чисел: пройти по последовательности значений и посчитать основные статистики за *один проход*, не сохраняя дополнительные структуры данных.

## Что нужно сделать

1) Описать тип `Stats` со следующими полями:
- `Count` — количество элементов
- `Sum` — сумма элементов
- `Min` — минимальный элемент
- `Max` — максимальный элемент

Рекомендуемые типы:
- `Count int`
- `Sum int64`
- `Min int64`
- `Max int64`

2) Реализовать функцию:

func Calc(xs []int64) Stats


Она должна возвращать агрегированную статистику по входному слайсу.

## Правила и ожидаемое поведение

- Для пустого слайса `[]int64{}` функция должна вернуть нулевое значение структуры: `Stats{}`.
  - То есть `Count == 0`, а остальные поля остаются равными `0`.
- Для непустого слайса:
  - `Count` равен количеству элементов
  - `Sum` равна сумме всех элементов
  - `Min` — минимальное значение среди элементов
  - `Max` — максимальное значение среди элементов

Примеры (как в тестах):
- `Calc([]int64{}) -> Stats{}`
- `Calc([]int64{42}) -> Stats{Count: 1, Sum: 42, Min: 42, Max: 42}`
- `Calc([]int64{1,2,3,4,5}) -> Stats{Count: 5, Sum: 15, Min: 1, Max: 5}`

## Важные ограничения (почему это «потоковая» агрегация)

- Алгоритм должен быть O(n) по времени и O(1) по дополнительной памяти.
- Нельзя сортировать слайс ради `Min/Max`.
- Нельзя создавать копии слайса или хранить промежуточные коллекции.

Идея «потоковости» в том, что те же действия можно выполнять, читая значения из любого источника (файл, сеть, канал) по одному — но в этом задании вход дан как `[]int64`.