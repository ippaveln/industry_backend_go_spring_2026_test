#  LRU cache + interface

Нужно реализовать LRU-кэш (Least Recently Used) с дженериками и интерфейсом. Поведение кэша проверяется автотестами (см. *_test.go). Ваша задача — написать код так, чтобы все тесты проходили.

Что такое LRU
- Кэш хранит не больше capacity пар key -> value.
- Если добавить новый ключ, а кэш уже заполнен, нужно удалить “самый давно неиспользованный” элемент (LRU).
- “Использование” — это успешный Get(key) и любой Set(key, value) (включая обновление уже существующего ключа). Использованный ключ становится “самым свежим” (MRU).

Требования к API (имена важны)
1) Интерфейс LRU[K, V]
- Должен существовать интерфейс с именем LRU.
- *LRUCache[K, V] должен реализовывать этот интерфейс (тест проверяет это через присваивание).
- Минимально необходимы методы:
  - Get(key K) (V, bool)
  - Set(key K, value V)

2) Конструктор
- Должна быть функция:
  - NewLRUCache[K, V](capacity int) *LRUCache[K, V]
- Тесты создают кэш именно так.

3) Тип кэша
- Должен существовать тип LRUCache[K, V] (как правило, struct).
- Рекомендуемая сигнатура (важно: ключи должны быть сравнимыми):
  - type LRUCache[K comparable, V any] struct { ... }

Правила поведения (ровно под тесты)
- Set для нового ключа:
  - добавляет элемент;
  - делает ключ MRU;
  - если после добавления размер стал больше capacity, удаляет LRU-элемент.
- Set для существующего ключа (overwrite/update):
  - обновляет значение;
  - делает ключ MRU;
  - НЕ должен вызывать eviction (вытеснение) сам по себе, потому что размер не растёт.
- Get:
  - если ключ найден: возвращает (value, true) и делает ключ MRU;
  - если ключ не найден: возвращает (zeroValue(V), false).
- Нулевая ёмкость:
  - при capacity == 0 кэш ничего не хранит: любой Set фактически “не сохраняет”, любой Get всегда miss (ok=false).
- Важно про zero value:
  - отсутствие ключа должно отличаться от “ключ есть, но значение равно zero value” — отличие обеспечивается флагом ok.

Ограничения и ожидания по реализации
- Ожидаемая асимптотика: Get и Set в среднем за O(1).
- Потокобезопасность не требуется.

- При добавлении нового ключа — вставлять в голову; если превышена ёмкость — удалить хвост и соответствующий ключ из map.

Что нужно сдать
- Реализацию интерфейса, типа кэша и конструктора с точными именами.
- Код должен компилироваться и проходить все тесты.

Минимальный “скелет” (для ориентира по именам)

type LRU[K comparable, V any] interface {
 Get(key K) (V, bool)
 Set(key K, value V)
}

type LRUCache[K comparable, V any] struct {
 // ваше хранилище
}

func NewLRUCache[K comparable, V any](capacity int) *LRUCache[K, V] {
 // ваша инициализация
 return &LRUCache[K, V]{}
}

![task 06](../../badges/tasks/task_06.svg)