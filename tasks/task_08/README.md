# Практическое задание: Rate limiter (Token Bucket) 

Цель: реализовать потокобезопасный rate limiter по алгоритму *token bucket* и покрыть его детерминированными юнит‑тестами с фейковыми часами (без `time.Sleep`).

## Что нужно реализовать

Нужно реализовать тип `Limiter` и его API:
```go
type Clock interface {
    Now() time.Time
}

type Limiter struct{ /* ... */ }

// ratePerSec — скорость пополнения (токенов в секунду), может быть дробной (например 2.5).
// burst — максимальная ёмкость корзины в токенах.
func NewLimiter(clock Clock, ratePerSec float64, burst int) *Limiter

// Allow возвращает true, если на текущий момент есть хотя бы 1 токен и он успешно списан.
// Иначе возвращает false.
func (l *Limiter) Allow() bool
```

## Семантика (важно)

1) Token bucket:
- Токены накапливаются со временем с постоянной скоростью `ratePerSec` (токенов/сек).
- Корзина не может содержать больше токенов, чем `burst` (лишние токены “пропадают”).

2) “Burst в начале”:
- При создании лимитера корзина считается *полной*.
- То есть сразу после `NewLimiter(...)` можно выполнить подряд ровно `burst` успешных вызовов `Allow()`.

3) Поведение `Allow()`:
- Если токенов >= 1: списать 1 токен и вернуть `true`.
- Если токенов < 1: вернуть `false`.

4) Дробные скорости:
- `ratePerSec` может быть дробным.
- Например, при `ratePerSec = 2.5` за 1 секунду накапливается 2.5 токена.
- Успешными будут только целые списания по 1 токену, пока `tokens >= 1`.

5) Граничные случаи:
- `burst == 0`: лимитер никогда не разрешает запросы (`Allow()` всегда `false`).
- `ratePerSec == 0`: токены не пополняются (разрешения возможны только из стартового burst).

6) Потокобезопасность:
- `Allow()` должен быть безопасен при одновременных вызовах из разных goroutine.
- Запуск `go test -race` не должен находить гонок данных.

## Ограничения

- Запрещено использовать реальное время внутри `Limiter` (никаких `time.Now()`).
- Источник времени — только переданный `Clock`.

## Что нужно покрыть тестами (минимум)

Юнит‑тесты должны быть детерминированными и проверять:

1) Начальный burst:
- сразу после создания `Allow()` возвращает `true` ровно `burst` раз подряд,
- следующий вызов возвращает `false`.

2) Расход токенов:
- при исчерпании токенов `Allow()` возвращает `false` без продвижения времени.

3) Восстановление со временем:
- при продвижении фейковых часов токены пополняются согласно `ratePerSec`,
- `Allow()` начинает снова возвращать `true` после накопления >= 1 токена.

4) Ограничение ёмкости:
- после большого прыжка по времени количество токенов не превышает `burst`.

5) Пограничные случаи:
- `burst=0` (всегда reject),
- `ratePerSec=0` (не пополняется),
- дробные `ratePerSec` (например 2.5 токена/сек).
